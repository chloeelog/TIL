# [TIL] 2021-09-06

> 알고리즘  - JavaScript

# 01. 최대 매출

> `슬라이딩 윈도우` 사용하여 `O(n)`으로 마무리하기!

### 코드

```jsx
function solution(nums, k) {
  let answer = 0;
  let sum = 0;

  // 초기값 설정 : 맨 처음 윈도우 값을 설정한다.
  for (let i = 0; i < k; i++) {
    sum += nums[i];
  }
  answer = sum;

  // 다음부터 윈도우를 밀어나간다: 
  for (let i = k; i < nums.length; i++) {
    sum += (nums[i] - nums[i - k]);
    answer = Math.max(answer, sum);
  }

  return answer;
}

console.log(solution([12, 15, 11, 20, 25, 10, 20, 19, 13, 15], 3))
```

# 02. 매출액의 종류

> 해시맵을 만들어서 카운팅해보자!

### 내 코드 after : ⚠️ 디버깅 필요!

```jsx
function solution(nums, k) {
  let answer = [];

  let sH = new Map();
  
  // 맨 첫 윈도우 값을 해시맵에 매핑하기
  for (let x of nums.slice(0, k)) {
    sH.set(x, sH.get(x) + 1 || 1);
  }

  // 다음 윈도우 값부터, 
  for (let i = k; i < nums.length; i++) {
    const lt = nums[i - k + 1]
    const rt = nums[i]

    sH.set(rt, sH.get(rt) + 1 || 1);
    sH.set(lt, sH.get(lt) - 1);
    if (!sH.get(lt)) {
      sH.delete(lt);
    }

    answer.push(sH.size)
  }

  return answer;
}

console.log(solution([20, 12, 20, 10, 23, 17, 10], 4))
```

- 이 때, `lt`의 값이 해시맵 안에서 0이 된다면 해당 키를 삭제해주는 것을 잊지 말자.

# 03. 연속 부분수열 1

> 마찬가지로 `O(n)` 으로 끝내버리자!

### 내 코드 : after ⚠️ 디버깅 필요 어디서 터졌을까

```jsx
function solution(nums, m) {
  let answer = 0;

  let lt = 0;
  let sum = 0;

  for (let rt = 0; rt < nums.length; rt++) {
    while (sum < m) {
      sum += nums[rt];
      if (sum === m) {
        answer++;
      }
    }
    while (sum > m) {
      sum -= nums[lt];
      if (sum === m) {
        answer++;
      }
      lt++;
    }
  }

  return answer;
}

console.log(solution([1, 2, 1, 3, 1, 1, 1, 2], 6))
```

# 04. 연속 부분수열 2

> `해시맵`을 쓰자!
`lt`, `rt`의 투포인트로 해결할 수 없다! 주의할 것.

### guideline

1. 해시맵을 생성하자
2. 0번 인덱스부터 현재 인덱스까지의 누적합 sum을 설정하고, 
3. sum이 원하는 값인지 확인하고,
    1. 만약 원하는 값이라면 answer에 해당 케이스를 적립해준다. 
4. 동시에 sum값에서 타겟 값을 뺀 값이 해시키에 있는지 확인한다. 
    1. 만약 해당 값이 해시키에 존재한다면 :
        - `0번 인덱스부터 현재 인덱스까지 구간` 에서 `0번 인덱스부터 특정 인덱스까지의 구간` 을 뺀 값이 타겟값이 된다는 뜻!
        - 따라서 해당 값의 밸류값만큼을 answer에 더해주면 된다.
5. 그리고 sum을 해시맵의 키로 설정해 해시맵을 생성하고 해당 sum의 빈도수를 밸류에 적립한다.
    - 이 과정은 맨 마지막에 해주어야 한다!
        - 왜냐면 sum = m = 0인 경우가 있을 수 있으므로. 내 값이 존재하는 경우를 먼저 적립해줄 수는 없다.

 

### 내 코드 : after

```jsx
function solution(nums, m) {
  let answer = 0;

  let nH = new Map();
  let sum = 0;

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    
    if (sum === m) {
      answer++;
    }
    
    if (nH.has(sum - m)) {
      answer += nH.get(sum - m);
    }

    nH.set(sum, nH.get(sum) + 1 || 1);
  }

  return answer;
}

console.log(solution([1, 2, 3, -3, 1, 2], 3))
console.log(solution([-1, 0, 1], 0))
console.log(solution([-1, -1, -1, 1], 0))
console.log(solution([0, 0, 0, 0, 0], 0))
```

# 05. 연속 부분수열 3

> `lt`, `rt` 투포인트를 설정

### guideline

1. lt, rt를 설정하고
2. rt를 증가시켜가며 rt를 끝으로 하는 부분수열의 합을 구해준다. 
    1. 만약 해당 수열의 부분합이 타겟 넘버보다 작다면 rt를 계속 증가시킨다.
    2. 만약 해당 수열의 부분합이 타겟 넘버보다 크다면, lt를 증가시킨다.
3. rt, lt가 주어졌다는 것은 :
    - `lt부터 ~ rt까지`, `lt+1 지점부터 ~ rt까지` , `lt+2 지점부터 ~ rt까지` 의 부분합들이 모두 타겟 넘버보다 작다는 뜻이므로,
    - 해당 구간의 경우의 수인 `(rt - lt + 1)` 을 answer에 더해주면 된다!


# 06. 연속된 자연수의 합

> 연속된 부분 수열 1번과 같되, 배열 초기화를 한 것!

**⚠️ `RangeError` 발생하는 코드입니다. 디버깅 필요!**

```jsx
function solution(n) {
  let answer = 0, sum = 0;
  let m = parseInt(n / 2) + 1;
  let nums = Array.from({length: m}, (v, i) => i + 1);
  let lt = 0;

  for (let rt = 0; rt < m; rt++) {
    sum += nums[rt];
    if (sum === n) answer++;
    while (sum > n) {
      sum -= nums[lt++];
      if (sum === n) answer++;
    }
  }

  return answer;
}

console.log(solution(15))
console.log(solution(45678))
console.log(solution(98765))
```

### 또 다른 방법 : 수학적 접근?

- 이거 어떻게 가능하지?

```jsx
function solution(n) {
  let answer = 0;
  let cnt = 0;

  n--;

  while (n > 0) {
    cnt++;
    n -= cnt;
    if (n % cnt === 0) answer++;
  }
  return answer;
}
```

# 07. 모든 아나그램 찾기

> `해쉬`, `투포인터`, `슬라이딩 윈도우`

- 다른 언어에서는, 해시맵을 두 개 만들어서 같은 객체인가 비교하는 것이 가능하다.
    - 파이썬에서는 `==`으로 가능! Java도 equal로 가능!
    - 그러나 JS에서는 없음!

### guideline

1. 결과값의 기준이 될 T문자열의 해시맵을 생성하되, 각 키 값을 음수로 설정한다.
    - `abc`의 경우 해시맵은 `{a: -1, b: -1, c: -1}`, `aab`인 경우 `{a: -2, b: -1}`가 된다!
2. `lt = 0`, `rt = 기준 T문자열의 길이 - 1` 로 초기값을 설정한다. 
    - 아나그램 문자열의 길이는 정해져 있다: T.length
    - 따라서 앞으로 lt와 rt는 반드시 T.length의 간격을 유지하게 된다.
    - 우선 첫 케이스의 경우를 해시맵에 맵핑해주고 시작한다.
3. 해시맵의 사이즈가 0이 되는지를 확인한다: 
    - 해당하는 경우 아나그램에 해당하므로 answer를 증가시킨다.
4. 이후 순차적으로 `lt`와  `rt`를 하나씩 증가시키되,
    1.  rt 인덱스에 해당하는 값을 해시맵에 양수로 맵핑하고,
    2. lt 인덱스에 해당하는 값은 해시맵에 음수로 맵핑한다.
5. 해시맵의 사이즈가 0이 되는지를 확인한다.

### 코드

```jsx
function solution(s, t){
    let answer=0;
    let sH = new Map();
    for(let x of t){
        sH.set(x, sH.get(x)-1 || -1);
    }
    let len=t.length-1;
    for(let i=0; i<len; i++){
        if(sH.get(s[i])===-1) sH.delete(s[i]);
        else sH.set(s[i], sH.get(s[i])+1 || 1);
    }
    let lt=0;
    for(let rt=len; rt<s.length; rt++){
        if(sH.get(s[rt])===-1) sH.delete(s[rt]);
        else sH.set(s[rt], sH.get(s[rt])+1 || 1);
        if(sH.size===0) answer++;
        if(sH.get(s[lt])===1) sH.delete(s[lt]);
        else sH.set(s[lt], sH.get(s[lt])-1 || -1);
        lt++;
    }
    return answer;
}
console.log(solution("bacacbcba", "abc"));
```

- `||` 구문의 단축판단에 주의할 것!
    - `sH.set(s[rt], sH.get(s[rt]) + 1 || 1)` 에서 원 키 값이 -1일 경우, 여기에 1을 더하면 0이 된다.
    - 그러나 이 때 0은 false이므로 OR의 단축판단으로 뒤 항인 1을 반환하는 오류가 생긴다.
    - 그렇기에 다음과 같이 검증하도록 하자!

    ```jsx
    sH.set(s[rt], (sH.get(s[rt]) || 0) + 1);
    if (sH.get(s[rt]) === 0) sH.delete(s[rt]);
    ```