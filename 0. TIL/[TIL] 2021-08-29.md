# [TIL] 2021-08-29

> CS - JavaScript



* 프론트엔드 면접 질문 기출 문제들 중 JavaScript와 관련한 내용을 리스트업하고, 해당 내용에 대해서 공부했다. 



# new 연산자

사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성

1. 함수를 작성해 객체 타입을 정의
2. new 연산자로 객체의 인스턴스 생성

## 생성자 함수

- 이름의 첫 글자를 대문자로 시작
- new 연산자를 붙여 실행

```jsx
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

const car1 = new Car('Eagle', 'Talon TSi', 1993);

console.log(car1.make);
// expected output: "Eagle"
```

어떤 함수든 new를 붙여 사용하면 생성자 함수로 사용 가능

## new Car(...)를 써서 함수를 실행했을 때

1. Car.prototype을 상속하는 새로운 빈 객체가 하나 생성되고 `this`에 할당된다.
2. 함수 본문을 실행하며 `this`에 새로운 property를 추가해 수정한다.
3. `this`를 return한다.

*prototype : 객체의 원형

*property : 객체 내부의 속성

## new 연산자를 사용하는 이유

사용자 정의 객체를 생성 및 초기화 할 수 있다.

재사용 가능한 객체 생성 코드를 구현할 수 있다



# this

모든 함수는 실행될 때마다 내부에 `this`라는 객체가 추가된다

arguments와 함께 함수 내부로 암묵적으로 전달된다

## 전역 문맥

전역 실행 맥락에서 this는 전역 객체를 참조

```jsx
// 웹 브라우저에서는 window 객체가 전역 객체
console.log(this === window); // true
a = 37;
console.log(window.a); // 37
this.b = "MDN";
console.log(window.b)  // "MDN"
console.log(b)         // "MDN"
```

## 함수 문맥

함수가 호출된 상황에 따라 값이 다르게 결정

### 1. 객체의 메소드 호출

함수를 실행할 때 함수를 소유하고 있는 객체를 참조한다

즉 해당 메소드를 호출한 객체로 바인딩 된다

```jsx
var myObject = {
  name: "foo",
  sayName: function() {
    console.log(this);
  }
};
myObject.sayName();
// console> Object {name: "foo", sayName: sayName()}
```

### 2. 함수 호출

함수 B를 A.B 구조로 볼 때 A는 전역객체이므로 전역 객체에 바인딩 된다.

*전역 객체 : 전역 범위에 항상 존재하는 객체

```jsx
var value = 100;
var myObj = {
  value: 1,
  func1: function() {
    console.log(`func1's this.value: ${this.value}`);

    var func2 = function() {
      console.log(`func2's this.value ${this.value}`);
    };
    func2();
  }
};

myObj.func1();
// console> func1's this.value: 1
// console> func2's this.value: 100
```

### 3. 생성자 함수를 통해 객체 생성

new 연산자를 통해 호출된 함수 내부에서의 `this`는 객체 자신이다

```jsx
var Person = function(name) {
  console.log(this);
  this.name = name;
};

var foo = new Person("foo"); // Person
console.log(foo.name); // foo
```

### 4. apply, call, bind를 통한 호출

`this`를 JS코드로 주입 또는 설정할 수 있는 방법

#### call

```jsx
function add(c, d) {
  return this.a + this.b + c + d;
}

var o = {a: 1, b: 3};

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 이어지는 인자들은 함수 호출에서 인수로 전달된다.
add.call(o, 5, 7); // 16
```

#### apply

```jsx
function add(c, d) {
  return this.a + this.b + c + d;
}

var o = {a: 1, b: 3};

// 첫 번째 인자는 'this'로 사용할 객체이고,
// 두 번째 인자는 함수 호출에서 인수로 사용될 멤버들이 위치한 배열이다.
add.apply(o, [10, 20]); // 34
```

#### bind

f.bind(someObject)를 호출하면 this는 원본 함수를 가진 새로운 함수를 생성

새 함수의 this는 호출 방식과 상관없이 영구적으로 bind()의 첫 번째 매개변수로 고정

```jsx
function f() {
  return this.a;
}

var g = f.bind({a: 'azerty'});
console.log(g()); // azerty

var h = g.bind({a: 'yoo'}); // bind는 한 번만 동작함!
console.log(h()); // azerty

var o = {a: 37, f: f, g: g, h: h};
console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty
```

## bind, apply, call의 차이점

### bind

함수를 선언할 때 this와 파라미터를 지정한다

첫번째 인자로 this를 넘겨주고 각각의 파라미터도 하나씩 넘겨준다

this는 영구적으로 bind()의 첫번째 매개변수로 고정된다

### apply

함수를 호출할 때 this와 파라미터를 지정한다

첫번째 인자로 this를 넘겨주고, 두번째 인자로 넘겨줘야하는 파라미터를 배열의 형태로 전달한다

넘겨주는 객체에 따라 this 값도 변경된다

### call

함수를 호출할 때 this와 파라미터를 지정한다

첫번째 인자로 this를 넘겨주고 각각의 파라미터도 하나씩 넘겨준다

넘겨주는 객체에 따라 this 값도 변경된다

## 5. 화살표 함수

함수가 선언될 때 `this`에 바인딩 될 객체가 정적으로 결정

언제나 상위 스코프의 `this`를 가리킨다

```jsx
function Person(){
  this.age = 0;

  setInterval(() => {
    this.age++; // |this|는 Person 객체를 참조
  }, 1000);
}

var p = new Person();
```

화살표 함수는 call, apply, bind 메소드를 사용하여 this를 변경할 수 없다.

```jsx
window.x = 1;
const normal = function () { return this.x; };
const arrow = () => this.x;

console.log(normal.call({ x: 10 })); // 10
console.log(arrow.call({ x: 10 }));  // 1
```