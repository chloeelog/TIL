# [TIL] 2021-09-04

> 알고리즘  - JavaScript



# 01. 숫자통일 문제

> 문자열을 탐색해가면서 1의 연속구간의 갯수는 몇 개, 0의 연속구간의 갯수는 몇 개인지 세어볼 것. 개중 더 작은 값을 바꿔주면 된다.

- 문자열을 탐색하며 연속 구간의 갯수를 세 보면 된다.

### guideline

1. `s[0]`이 어떤 숫자인지 확인한다.
2. if 해당 숫자가 1이라면, one이라는 변수를 만들어 1의 연속 구간의 갯수를 센다. else 해당 숫자가 0이라면 zero라는 변수를 만들어 0의 연속 구간의 갯수를 센다.
3. for문을 이용하여 1번 인덱스부터 비교해본다. i번 인덱스의 숫자와 i-1번 인덱스의 숫자를 비교하여, 서로 다른 숫자일 경우를 카운트해보자.

### 코드

```jsx
function solving(s) {
  let answer;
  let zero = 0, one = 0;
  if (s[0] === "1") one = 1;
  else zero = 1;

  for (let i = 1; i < s.length; i++) {
    // 현재 위치는 i에 있고, s[i]와 전 숫자가 다를 경우 s[i]로 새로운 구간이 시작되는 것.
    if (s[i - 1] !== s[i]) {
      if (s[i] === "1") one++;
      else zero++;
    }
  }
  answer = Math.min(one, zero);
  return answer;
}

console.log(solving("100110011"));
```

# 02. 상태변화

### guideline

1. 두 문자열의 같은 인덱스(같은 위치)의 문자를 탐색하여 비교한다.
2. 0으로 뒤집어야 하는 1의 갯수는 zero로, 1로 뒤집어야 하는 0의 갯수는 one으로 잡아가며 카운트한다.
3. zero, one중 더 큰 값을 반환한다.

### 코드

```jsx
function solution(s1, s2) {
  let zero = 0, one = 0;

  for ( let i = 0; i < s1.length; i++ ) {
    if ( s1[i] === '1' && s2[i] === '0' ) {
      zero++;
    } else if ( s1[i] === '0' && s2[i] === '1' ) {
      one++;
    }
  };

  let answer = Math.max(zero, one);
  return answer;
}

console.log(solution("11000111", "11100110"))
```

# 03. 접미사 정렬

### guideline

1. 문자열의 각 문자를 차례로 순회하며,
2. 인덱스 i 부터 시작하여 뒷부분의 문자를 substring 한다.

### 코드

```jsx
function solving(s) {
  let answer = [];
  for ( let i = 0; i < s.length; i++ ) {
    answer.push(s.substring(i, s.lenght));
  }
  answer.sort();
  return answer;
}
```

# 04. 공통문자가 없는 단어

### guideline

1. i번째 문자열과 j = i + 1의 문자열을 이중 for문으로 돌려가며 선정하여
2. 두 문자열을 꺼낸 뒤, 각 문자열의 글자가 unique하다는 것을 확인하고
   - `indexOf`를 활용할 수 있다!
3. unique할 경우 두 문자열의 길이를 곱해서
4. 최댓값을 출력해본다.

### 코드

```jsx
function solution(words) {
  let answer = 0;
  let len = words.length;

  // 문자들을 더 짧은 순서대로 정렬한다. 더 짧은 길이의 문자열을 기준으로 검토하도록. 
  words.sort((a, b) => a.length - b.length);

  for ( let i = 0; i < len-1; i++ ) {
    for ( let j = 0; j < len; j++ ) {
      if ( isUnique(words[i], words[j]) ) {
        let tmp = words[i].length * words[j].length;
        answer = Math.max(answer, tmp);
      };
    };
  };

  function isUnique(short, long) {
    // range-base for문을 사용해본다!
    for ( let x of short ) {
      if ( long.indexOf(x) !== -1 ) return false;
    };
    return true;
  };

  return answer;
}

console.log(solution(["skudy", "kstue", "time", "back", "good"]))
```

# 05. 회문문자열2

- 회문 풀 때
  - split하고 reverse 하여 join
  - 혹은 twopoint로 비교

### guideline

1. 맨 앞부터 순회하는 변수 lt, 맨 뒤부터 순회하는 변수 rt를 설정하자.
2. `while ( lt < rt )` 일 동안 두 문자를 비교한다.
3. 두 문자가 같으면 통과, 같지 않을 경우 두 경우로 나눠 두 문자를 각각 지워본다.
   - substring()을 이용하여 각 경우 비교해야 할 문자를 분리해낸다.
4. 분리된 두 문자열 중 어느 것이든 한 개만 회문이 성립한다면 해결!
   - `split`, `reverse`, `join`을 이용하여 확인할 것!

### 코드

```jsx
function solution(s) {
  let answer = "YES";
  let lt = 0,
    rt = s.length - 1;

  while (lt < rt) {
    if (s[lt] !== s[rt]) {
      let s1 = s.substring(lt, rt);
      let s2 = s.substring(lt + 1, rt + 1);

      if (
        s1.split("").reverse().join("") !== s1 &&
        s2.split("").reverse().join("") !== s2
      ) {
        answer = "NO";
      }
      break;
    } else {
      lt++;
      rt--;
    }
  }
  return answer;
}

console.log(solution("abcbdcba"));
```

# 06. 학급 회장

### guideline

1. `map`을 사용하자!
2. `.set()`, `.get()`, `.delete()`, `.has()`, `.size()` 를 이용하자!

### 코드

```jsx
function solution(s) {
  let answer;

  let sH = new Map();

  for ( let x of s ) {
    sH.set(x, sH.get(x) + 1 || 1);
  };

  let max = Number.MIN_SAFE_INTEGER;
  
  for ( let [key, val] of sH ) {
    if (val > max) {
      max = val;
      answer = key;
    };
  };
  return answer;
};
```

# 07. 아나그램

### 코드

```jsx
function solution(s1, s2) {
  let answer = "YES";

  let sH = new Map();

  for ( let x of s1 ) {
    sH.set(x, sH.get(x) + 1 || 1);
  };
  
  for ( let x of s2 ) {
    if ( !sH.has(x) || sH.get(x) === 0 ) answer = "NO";
    sH.set(x, sH.get(x) - 1)
  }
  
  return answer;
};

console.log(solution("AbaAeCe", "baeeACA"))
```

# 08. 문자열 구분하기

### guideline

1. 맨 앞부터 인덱스를 늘려가며 접두어를 substring() 한다.
2. substring 된 문자열들을 key로 넣어 Map한다!
3. key를 갖고있는지 확인해보고, 갖고있다면 false.

### 코드

```jsx
function solution(words) {
    let answer = 0;
    let i; //i = 접두어 길이 (최종답 : i+1)

    //문자열의 길이를 늘려가면서 비교, 문자열길이가 갱신 될 때마다 map 새롭게 생성
    //첫 번째 단어의 길이만큼 반복
    for (i = 0; i < words[0].length; i++) {
        let sh = new Map();
        let flag = true;
        for (let j = 0; j < words.length; j++) { //첫 단어부터 마지막 단어까지 접근
            let x = words[j].substring(0, i + 1);
            if (sh.has(x)) { //키가 있다면 unique 하지 않는 것.
                flag = false;
                break;
            }
            sh.set(x, 1); //키가 없다면 설정해줌
        }

        if (flag) break;
    }
    answer = i + 1;
    return answer;
}

//test case
//console.log(solution(["seeasue", "sesseysu", "semeas"]));
//console.log(solution(["longlong", "longtong", "longbig"]));
```
