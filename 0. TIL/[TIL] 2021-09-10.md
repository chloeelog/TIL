# [TIL] 2021-09-10

> 알고리즘  - JavaScript

# 01. 재귀함수를 이용한 이진수 출력

# 02. 이진트리 순회(깊이우선탐색: DFS)

# 03. 부분집합 구하기(DFS)

### 코드

```jsx
function solution(n){
    let answer=[];
    let part=[];
    function DFS(L){
        if(L===n+1){
            if(part.length!==0) answer.push(part.slice());
        }
        else{
						part.push();
						DFS(L+1);
            part.pop();
            DFS(L+1);
        }
    }
    DFS(1);
    return answer;
}

console.log(solution(3));
```

- `function DFS(L)` :
    - L을 포함하거나 포함하지 않는 부분집합의 갯수를 세도록 분기한다.
    - `DFS : line 6` → L 을 포함하는 부분집합들의 경우의 수
    - `DFS : line 8` → L을 포함하지 않는 부분집합들의 경우의 수
- 얕은복사가 아닌 깊은복사를 사용할 것 : `slice()`

    [Array.prototype.slice() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)

- 높은 차수에서 낮은 차수로 내려가는 방향으로

    ```jsx
    function solution(n){
      let answer=[];
      let part=[];
      function DFS(L){
        if (L === 0) {
          if (part.length !== 0) answer.push(part.slice());
        } else {
          part.push(L);
          DFS(L - 1);
          part.pop(L);
          DFS(L - 1);
        }
      }
      DFS(n);
      return answer;
    }
    ```

# 04. 합이 같은 부분집합

> 매개변수를 활용하여 더하면서 전진하자!

### guideline

1. `DFS(Level, Sum)`의 형태로 함수를 정의한다. 
    - Level은 주어진 원 배열의 인덱스 번호
    - Sum은 해당 레벨(인덱스)값 까지의 부분합
    - `Level === 원배열.length` 인 순간 종료된다!

### 내 코드 : after : 문제를 잘못이해했어!
+ sum 이렇게 누적해도 되는지 확인해보자!
++ 아마 되는거같다!

```jsx
function solution(nums){
  let answer = "NO";

  let sums = [];

  function DFS(L, sum) {
    if (L === nums.length) {
      sums.push(sum);
    } else {
      DFS(L + 1, sum);
      sum += nums[L];
      DFS(L + 1, sum);
    }
  }

  const set = new Set(sums);

  if (sums.length !== set.length) answer = "YES";
  return answer;
}
```

# 05. 바둑이 승차(DFS)

> 가지치기 중 불필요한 경우는 걸러내주어야 한다. 효율성의 문제!

### 내 코드

```jsx
function solution(nums, C){
  let answer = 0;

  function DFS(L, sum) {
    if (L === nums.length) {
      answer = Math.max(answer, sum);
    } else {
      // L의 바둑이를 포함하지 않는 경우
      DFS(L + 1, sum);
      // L의 바둑이를 포함하여 세는 경우
      sum += nums[L];
      if (sum < C) {
        DFS(L + 1, sum);
      } else if (sum === C) {
        answer = C;
        return;
      }
    }
  }
  DFS(0, 0);

  return answer;
}

console.log(solution([81, 58, 42, 33, 61], 259));
console.log(solution([34, 56, 55, 67, 33, 76, 63, 43], 379));
```

### guideline

- 위 문제와 같은 방식이되, cut edge 하는 경우를 위해 매개변수 하나를 더 넘긴다.
- 현재 경우까지의 합이 C보다 큰 경우 더 이상 구하지 않는다.
- 남아있는 강아지들의 무게의 합을 현재의 값에 더했을 때 누적된 최대합보다 크지 않을 경우 더 이상 구하지 않는다.
    - `tsum` : 현재까지 검증한 모든 강아지의 무게를 다 더한 값
    - `total - tsum` : 남아있는 모든 강아지를 다 더했을 경우의 값


# 06. 최대점수 구하기

- cut edge 해야 하는 경우 :
    1. 걸리는 시간을 초과할 때
    2. 남아있는 점수들을 다 더했을때도 이전 경우의 최대 점수를 넘지 못할때
- 강사님은 cut edge 하지 않고 푸셨다!

  

### 내 코드 : after

```jsx
function solution(nums, m){
  let answer = 0;
  let total = nums.reduce((a, b) => a + b[0], 0);

  function DFS(L, time, score, tscore) {
    if (L === nums.length) {
      answer = Math.max(answer, score);
    } else {
      tscore += nums[L][0]
      // 해당 문제를 풀지 않는 경우
      DFS(L + 1, time, score, tscore);

      // 해당 문제를 푸는 경우
      time += nums[L][1];
      score += nums[L][0];
      if (time <= m && score + (total - tscore) >= answer) {
        DFS(L + 1, time, score, tscore);
      } else {
        return;
      }
    }
  }

  DFS(0, 0, 0, 0);
  return answer;
}

console.log(solution([[10, 5], [25, 12], [15, 8], [6, 3], [7, 4]], 20));
console.log(solution([[15, 6], [30, 11], [23, 8], [14, 4], [10, 3], [20, 7]], 25));
```

# 07. 중복순열 구하기

> M번을 뽑으므로 M중 for문의 방식을 사용할 수 밖에 없다. 재귀를 활용하여 풀어본다.

- 이 때 `L`은 몇 번째까지 뽑았는가 하는 것을 파악하기 위한 것!
- 다음 레벨(`L + 1`)로 넘어가는 경우, 이전에 반드시 무엇인가 하나를 넘겨주었으므로 `L`번째까지의 값은 모두 채워서 배정된 상태이다.

# 08. 순열 구하기

### 순열 구하기

- 원본 코드

    ```jsx
    function solution(n, m){
      let answer = [], tmp = [];
      let ch = Array.from({length: n + 1}, () => 0);
    
      function DFS(L) {
        if (L === m) {
          answer.push(tmp.slice());
        } else {
          for (let i = 1; i <= n; i++) {
            if (ch[i] === 0) {
              ch[i] = 1;
              tmp.push(i);
              DFS(L + 1);
              tmp.pop();
              ch[i] = 0;
            }
          }
        }
      }
      DFS(0);
      return answer;
    }
    
    console.log(solution(10, 10))
    ```

### 내 코드 : 원본배열을 갈아끼면 안 될것같은데?

```jsx
function solution(n, m){
  let answer = [], tmp = [];

  function DFS(L) {
    if (L === m) {
      answer.push(tmp.slice());
    } else {
      for (let x of n) {
        tmp.push(x);
        n = n.filter((element) => element !== x);
        DFS(L + 1);
        tmp.pop();
        n.push(x);
      }
    }
  }

  DFS(0);
  return answer;
}

console.log(solution([3, 6, 9], 2));
```

- 이 때 원 조합의 순서가 바뀌면 어떻게되는데? for ... of의 내부 알고리즘이 궁금하다!

### 가이드라인

- 체크 배열을 따로 만들어, 사용한 경우 체크하고 넘어간다.

# 09. 조합의 경우수(메모이제이션)

## 개념 정리 : 조합

$nCr = n-1Cr-1 + n-1Cr$

- n명을 조합하는 경우는,
    1. 특정 학생을 반드시 포함하고 나머지 학생들 중 n-1명을 조합하는 경우와
    2. 특정 학생을 절대 포함하지 않고 나머지 학생들 중 n명을 조합하는 경우
- 언제 return 되나요?
    - r 이 0되거나 (=1)
    - n과 r이 같아지는 경우 (=1)
- 메모이제이션 없이 풀어보는 경우 : 내 코드

    ```jsx
    function solution(n, m) {
      let answer = 0;
    
      function comb(n, r) {
        if (n === r || r === 0) {
          answer += 1;
          return;
        }
        comb(n - 1, r);
        comb(n - 1, r - 1);
      }
    
      comb(n, m);
      return answer;
    }
    
    console.log(solution(5, 3));
    ```

### Step 01. 조합을 구현하자

```jsx
function solution(n, r) {
  let answer;

  function DFS(n, r) {
    if (n === r || r === 0) return 1;
    else {
      return DFS(n - 1, r - 1) + DFS(n - 1, r);
    }
  }

  answer = DFS(n, r);
  return answer;
}

console.log(solution(5, 3));
```

### Step 02. 메모이제이션을 적용하자

```jsx
function solution(n, r) {
  let answer;

  let dy = Array.from(Array(35), () => Array(35).fill(0));

  function DFS(n, r) {
    if (dy[n][r] > 0) return dy[n][r];
    if (n === r || r === 0) return 1;
    else {
      return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r);
    }
  }

  answer = DFS(n, r);
  return answer;
}

console.log(solution(5, 3));
```

# 10. 수열 추측하기

> 수학적 접근:  `이항계수`를 이용하자!

### guideline

1. 답은 `1부터 N까지의 순열`들 중에 있다!
    - 사전순으로 가장 앞에 오는 것을 출력하라고 했으므로,  순열을 오름차순으로 나열한 후 앞에서부터 검증해보면 된다.
2. 가장 윗줄의 숫자들은 이항계수로 더해진다:
3. 따라서, 미리 이항계수 테이블을 만들어놓는다.
4. 주어진 숫자 N에 대하여,
    1. 순열로 조합한 N개 길이의 배열의 각 인덱스 값과
    2. N에 대한 이항계수 테이블 배열의 각 인덱스 값을 곱하여 구하자! 

### 이항계수 테이블 만들기

- 두 가지 방법으로 초기화 할 수 있다 :
    1. `b[i] = (b[i - 1] * (n - i)) / i`
        - 이항계수 트리를 살펴보면서 검토해볼 것!

        ```jsx
        b.push(1);
          for (let i = 1; i < n; i++) {
            b.push((b[i - 1] * (n - i)) / i);
          }
        ```

    2. combination 사용

# 11. 조합 구하기

## 개념 정리 : 조합의 경우

- for문을 돌되, 선택된 인덱스 다음 단계에서는 이 다음 인덱스들만 돈다는 것을 명심하자!

### 코드

```jsx
function solution(n, m) {
  let answer = [];
  let tmp = [];

  function DFS(L, s) {
    if (L === m) {
      answer.push(tmp.slice());
    } else {
      for (let i = s; i <= n; i++) {
        tmp.push(i);
        DFS(L + 1, i + 1);
        tmp.pop();
      }
    }
  }
  DFS(0, 1);
  return answer;
}

console.log(solution(4, 2));
```

- 조합을 이용해 부분집합을 구할 수 있다!
    - `L === n` 일 경우의 조합의 결과는 `원소 n` 개인 부분집합이다!
    - 집합을 출력해보면 알 수 있다!

        ```jsx
        function solution(n, m) {
          let answer = [];
          let tmp = [];
        
          function DFS(L, s) {
            let res = "";
            for (let x of tmp) res += x;
            console.log(res);
        
            for (let i = s; i <= n; i++) {
              tmp.push(i);
              DFS(L + 1, i + 1);
              tmp.pop();
            }
          }
          DFS(0, 1);
          return answer;
        }
        ```

# 12. 수들의 조합

ㅣ

### 내 코드

```jsx
function solution(nums, m, k) {
  let answer = 0;

  function DFS(L, s, sum) {
    if (L === m) {
      if (!(sum % k)) {
        answer++;
      }
    } else {
      for (let i = s; i < nums.length; i++) {
        DFS(L + 1, i + 1, sum + nums[i]);
      }
    }
  }

  DFS(0, 0, 0)
  return answer;
}

console.log(solution([2, 4, 5, 8, 12], 3, 6));
console.log(solution([3, 5, 7, 8, 9, 12, 14], 4, 8));
```