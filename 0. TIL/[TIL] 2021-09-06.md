# [TIL] 2021-09-06

> 알고리즘  - JavaScript

# 01. 올바른 괄호

## 개념정리 : 스택

- 자료의 삽입과 출력이 동일한 곳에서 진행된다 : 즉 `후입선출`; Last-In-First-Out의 구조!
- 배열에서 `push()`, `pop()`으로 구현할 수 있다.

### guideline

1. 스택을 생성하고,
2. 여는 괄호를 만나면 스택에 집어넣는다 : push
3. 닫는 괄호를 만나면 스택에서 여는 괄호를 꺼낸다 : pop
4. 닫는 괄호를 만났지만 스택에서 꺼낼 괄호가 없다면? : 올바른 괄호가 아니다!
5. 끝까지 순회했는데 스택에 여는 괄호가 남아있다면? : 올바른 괄호가 아니다!
- 스택 대신 cnt를 사용하여 여는 괄호에 증가, 닫는 괄호에 감소시켜도 좋다.

### 내 코드 before

**스택을 안 쓰는 경우**

```jsx
function solution(s) {
  let flag = 0;

  for ( let i = 0; i < s.length; i++ ) {
    (s.charAt[i] === '(') ? (flag += 1) : (flag -= 1)
  }

  if ( flag === 0 ) {
    return 'YES'
  } else {
    return 'N0'
  }
  
};

console.log(solution('(()(()))(()'))
```

**스택을 쓰는 경우**

```jsx
function solution(s) {
  let stack = [];

  for (let br of s) {
    if (br === '(') {
      stack.push(br);
    } else if (br === ')') {
      if (stack) {
        stack.pop();
      } else {
        return "NO";
      }
    }
  }
  if (stack) {
    return "NO";
  }
  
  return "YES";
}

console.log(solution('(()(()))(()'))
```


# 02. 괄호문자제거

> 스택을 이용하여 처리할 수 있다.

### guideline

1. 여는 괄호를 만나거나 문자를 만나면 : push()
2. 닫는 괄호를 만나면 :
    1. 스택의 가장 위에 있는 여는 괄호가 짝꿍이다. 여는 괄호를 만날때까지 스택을 모두 pop 한다.
    2. 여는 괄호를 만나면 멈춘다. 
3. 끝까지 반복한 뒤,
4. 스택에 남아있는 문자열을 반환한다. 

### 내 코드 after

```jsx
function solution(s) {
  let stack = [];

  for (let chr of s) {
    if (chr !== ')') {
      stack.push(chr)
    } else {
      while (stack.pop() !== '(');
    }
  }

  let answer = stack.join('')
  return answer;
}

console.log(solution('(A(BC)D)EF(G(H)(IJ)K)LM(N)'))
```


# 03. 후위식 연산(postfix)

> 면접 단골 문제! 중위식 연산을 후위식 연산으로 변경하기!


## 개념정리 : 전위/중위/후위

### 전위 순회/중위 순회/후위 순회

- 부모와 두 자식으로 구성된 트리 구조를 가정하자:
    - `전위 순회` : 부모노드 → 왼쪽자식노드 → 오른쪽자식노드
        - `prefix`
    - `중위 순회` : 왼쪽자식노드 → 부모노드 → 오른쪽자식노드
        - `infix`
    - `후위 순회` : 왼쪽자식노드 → 오른쪽자식노드 → 부모노드
        - `postfix`


### 중위 연산식을 후위 연산식으로 바꾸기

- 중위 연산식을 트리화한 후 후위순회한다!


### 후위연산식 연산하기

1. 연산식을 순회하며,
2. 피연산자(숫자)를 만나면 스택에 push 한다.
3. 연산자를 만나면 스택에서 피연산자 두 개를 pop한다.
    1. 이 때 먼저 나온 것을 오른쪽 자식 노드에, 나중에 나온 것을 왼쪽 자식 노드에 배정한다.
    2. 즉, 나중에 나온 피연산자가 연산당하는 것!
4. 연산한 결과를 스택에 push 한다.
5. 연산식을 다 순회하고 난 뒤 스택에는 단 하나의 값이 남아있다 : 이를 반환한다.

### 연습문제 : 중위연산식을 후위연산식으로 바꿔보자!

2 + 3 * 2 + (6 - 3) * 4

(2 + (3*2) ) + ((6-3) * 4)
(2 + (3*2))((6-3)*4) + 
232*+63-4*+ 


### 내 코드 after

```jsx
function solution(s) {
  let stack = [];

  const fix = ["+", "-", "*", "/"];
  for (let x of s) {
    console.log(`x는 이것인데요 ${x}`);
    if (!fix.includes(x)) {
      console.log(`${x}를 만나면`);
      stack.push(Number(x));
      console.log(`stack이 이렇게 돼요: ${stack}`);
    } else {
      const rt = stack.pop();
      const lt = stack.pop();

      console.log(`연산식 ${x}일때는?`)

      switch (x) {
        case "+":
          stack.push(lt + rt);
          console.log(`계산 후의 스택은: ${stack}`)
          break;
        case "-":
          stack.push(lt - rt);
          console.log(`계산 후의 스택은: ${stack}`)
          break;
        case "*":
          stack.push(lt * rt);
          console.log(`계산 후의 스택은: ${stack}`)
          break;
        case "/":
          stack.push(lt / rt);
          console.log(`계산 후의 스택은: ${stack}`)
          break;
        default:
          break;
      }
    }
  }
  return stack.pop();
}

console.log(solution("352+*9-"));
```

- 주의할 것! string을 숫자로 변환해서 넣어주어야 한다.


# 04. 연속된 문자 지우기


# 05. 공주 구하기

> `요세푸스`! Queue를 사용한다.

## 개념정리: 큐Queue

- 선입선출, First-In-First-Out
- 큐 배열의 첫 점을 front, 끝 점을 rear라고 한다.
- `push()`, `shift()`를 사용한다!

### guideline

1. 왕자의 번호가 담긴 queue를 생성한다.
    - `let queue = Array.from({length: 8}, (v, idx) => idx + 1)`
2. 큐가 빌 때까지 조건문while을 반복하며, 
    - `while (queue.length)`
    1. 맨 앞에서 꺼낸 왕자의 번호를 맨 뒤로 삽입하는 작업을 k-1번 반복한다. 
    2. for문이 종료된 다음, k번째로 만난 왕자의 번호는 큐에서 꺼내 삭제한다.
3. 큐에 한 명이 남았을 때 break한다.
4. 큐에 마지막까지 남은 왕자의 번호를 답으로 return 한다. 

### 내 코드 after

```jsx
function solution(n, k) {
  let queue = Array.from({length: n}, (v, idx) => idx + 1);

  while (queue.length) {
    for (let i = 0; i < k - 1; i++) {
      queue.push(queue.shift());
    }
    queue.shift();
    if (queue.length === 1) {
      return queue.shift();
    }
  }
}

console.log(solution(8, 3));
```


# 06. 교육과정 설계

> "같은 문자가 중복하여 들어올 수 있다" 는 것이 핵심! 문제의 장치다!

### guideline

1. 필수과목으로 받는 `need`를 `split()`을 이용하여 큐로 변화시킨다.
2. 다음...?

### 내 코드 ⚠️ 디버깅 필요

```jsx
function solution(need, plan) {
  let queue = need.split("");

  while (queue.length) {
    let todo = queue.shift();
    for (let cl of plan) {
      if (cl === todo) {
        todo = queue.shift();
        continue;
      }
    }
    return "NO";
  }

  if (queue.length) {
    return "NO";
  }

  return "YES";
}

console.log(solution("CBA", "CBDAGE"));
```

# 07. 최소 매출

> 이중 for문으로 풀 수도 있지만(`O(n^2)`), `O(n)`으로 끝내버리기!
데크가 꾸준히 오름차순을 유지하고 있다는 것이 포인트.

## 개념정리: 데크

### guideline

1. queue에 [배열의 값, 인덱스]를 묶어서 저장한다.
    - `[nums[i], i]`의 형태로 저장한다!
2. 다음...?


# 🌟 재귀함수

### 스택 프레임 이해하기:

- 출력 `3, 2, 1`

    ```jsx
    function DFS(v) {
      if (v === 0) {
        return;
      } else {
        console.log(v);
        DFS(v - 1);
      }
    }

    DFS(3)
    ```

- 출력 `1, 2, 3`

    ```jsx
    function DFS(v) {
      if (v === 0) {
        return;
      } else {
        DFS(v - 1);
        console.log(v);
      }
    }
    
    DFS(3)
    ```