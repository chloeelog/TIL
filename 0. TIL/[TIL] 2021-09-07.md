# [TIL] 2021-09-06

> 알고리즘  - JavaScript



# 단속카메라

## 접근방법

### 문제 살펴보기

- 우선 주어진 차량 배열을 진입 지점 순으로 정렬
  - 진입 지점이 같을 경우 더 빨리 진출하는 순으로 정렬

1. 배열의 맨 첫 요소를 기준으로 (남아있는 차량들 중 가장 먼저 진입하는 차량을 기준으로) 해당 차량의 진출 지점을 확인한다.

2. 이 진출 지점보다 먼저 진입하는 차량들 중, 가장 먼저 진출하는 차량을 확인한다.

   ⇒ 해당 차량의 진출 지점에 카메라를 설치한다.

3. 이 카메라 설치 지점을 기준으로, 이 지점보다 늦게 진입하는 차량들만 남기도록 배열을 슬라이싱한다.

4. 1번으로 돌아가 반복한다.

### 코드 작성하기

1. 차량 배열을 진입 지점 순으로 오름차순 / 같을 경우 진출 지점 순으로 오름차순 정렬 → `sort()` 함수 사용

2. 가장 처음 진입하는 차량의 진출 지점을 기준으로 더 일찍 진출하는 차량들 중 가장 먼저 진출하는 차량 확인

   1. 배열의 첫 번째 요소의 [1] 인덱스 값을 확인하고,
   2. 해당 값보다 작은 값들을 filter 한 후,
   3. filter된 값들 중 [1] 인덱스의 min 값을 찾는다 → Math 함수와 spread? 사용

3. 이 때 answer 값을 하나 증가시키고,

4. 해당 지점을 기준으로 나머지 배열을 잘라낸다

   → filter? slicing 가능?

## 제출 코드

### 첫 시도 : clear!

```jsx
console.clear();

function solution(routes) {
  var answer = 0;

  routes.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1];
    } else {
      return a[0] - b[0];
    }
  });

  while (routes.length > 0) {
    console.log(`${routes.length}길이의 배열이 남아있습니다.`)
    let temp = routes[0][1];
    console.log(`맨 처음 시작되는 배열은 ${temp}에서 진출합니다.`)
    let temparr = routes.filter(function (element, idx) {
      return element[1] <= temp;
    }).sort((a, b) => {
      return a[1] - b[1];
    });
    console.log(`${temparr.length} 길이의 배열 중에서 가장 빨리 진출하는 차량은?`)
    let camera = temparr[0][1];
    console.log(`${camera}에 카메라 한 대를 설치합시다!`)
    answer++;

    const newroutes = routes.filter(function (element, idx) {
      return element[0] > camera;
    });
    routes = newroutes;
  }

  return answer;
}

console.log(
  solution([
    [-20, 15],
    [-14, -5],
    [-18, -13],
    [-5, -3]
  ])
);
```

# 타겟 넘버

## 접근방법

> `완전탐색` 이라면 `해시맵`을 써야 할 것 같다. 
⇒ 아니다! 투포인터 알고리즘이다! ...인가? 아닌데...
⇒ 연속되지 않았으므로 투포인터를 쓸 수 없다. 
⇒ 우선 모든 경우를 다 해보는 DFS로 풀어보자?

## 제출 코드

### 첫 시도 = clear!

```jsx
function solution(numbers, target) {
  var answer = 0;

  function DFS(L, sum) {
    // L-1번째 인덱스의 숫자까지 계산된 상태입니다.
    // L번째 인덱스의 숫자를 배정할 차례입니다.
    if (L === numbers.length) {
      if (sum === target) {
        answer++;
      }
    } else {
      sum += numbers[L];
      DFS(L + 1, sum);
      sum -= (numbers[L] * 2);
      DFS(L + 1, sum);
    }
  }

  DFS(0, 0);
  
  return answer;
}
```
