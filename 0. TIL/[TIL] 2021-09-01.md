# [TIL] 2021-09-01

> Algorithm - 프로그래머스 문제 풀기 by JavaScript



# Algorithm - 섬 연결하기

# 접근방법

### 문제 살펴보기

- DP 테이블을 이용하여 푸는 문제!

  ⇒ 아니다, 크루스칼 + Union & Find로 풀어보자!

  - 크루스칼이 뭐지? 정리해볼 것
  - UnF 알고리즘도 정리해볼 것!

### 코드 작성하기

1. 다리의 건설 비용이 가장 작은 순으로 정보를 정렬합니다.

2. 각 섬들이 연결되었는가의 여부를 알려줄 일차원 배열 `unf`를 생성합니다.

   ⇒ 새 배열 생성하고 초기화하는 방법 정리하기!

   - `unf`는 `n+1`의 길이를 가진 일차원 배열입니다.
   - 일차원 배열 `unf`는 인덱스 번호 `i`에 `i`번 섬이 속한 집합의 번호를 갖습니다.
   - 아직은 탐색을 시작하지 않았으므로, 각 섬은 각자의 개별 집합에 속해 있는 상태입니다. `unf[i] = i`로 초기화 해줍니다.

3. `find(i)` 함수를 설정합니다. 주어진 i번 섬이 속한 집합 번호를 반환하는 함수입니다.

   1. 만약 `unf[i]`의 값이 `i`와 같다면, 그 값을 그대로 리턴합니다.

      - 이는 `i`번 섬이 아직 다른 섬과 연결되어 있지 않다는 뜻입니다.

   2. 만약 `unf[i]`의 값이 `i`와 같지 않다면, `unf[i]`값을 인덱스 번호로 하는 `unf`배열의 값을 참조하여 리턴합니다.

      - 즉, `i`번 섬이 `unf[i]`번 섬과 연결되어 있다는 뜻이며, 해당 섬과 같은 집합에 속해 있다는 뜻이 됩니다.

      - 탐색 과정에서 경로를 압축합니다 :

        - `unf[i]`번 섬이 이미 다른 섬과 연결된 상태라면, `unf[unf[i]]` 역시 `unf[i]`의 값을 갖지 않을 수도 있습니다.

        - 그러므로 이를 탐색하여 결괏값(`find(i)`)을 리턴할 때, 원배열  `unf[i]`에 그 값을 배정해가며 리턴하도록 합니다.

          ⇒ 경로가 압축되는 경우, 압축되지 않은 경우가 어떻게 다른지 정리해보도록 한다!

4. `union(a, b)` 함수를 설정합니다. 두 섬의 번호가 주어질 때, 두 섬의 `unf` 배열의 값이 동일하도록 설정해주는 함수입니다.

   - `unf[a] = b`

     ⇒ 이면 안된다! 왜 안되더라... 압축이 안되었기 때문...

5. 정렬된 다리의 정보를 순차적으로 탐색하며,

   - 우선 주어진 두 섬이 같은 집합에 속해 있는지 확인합니다 → find 함수 사용!
     1. 만약 두 섬이 이미 같은 집합에 속해 있는 상태라면, 탐색을 그만둡니다.
        - 두 섬은 이미 연결되었으므로 굳이 새로운 다리를 추가할 필요가 없기 때문입니다.
     2. 만약 두 섬이 같은 집합에 속해 있지 않다면, 해당 다리를 건설해야 합니다.
        - 주어진 다리를 건설하는 비용을 answer에 더합니다.
        - 두 섬을 연결합니다 → union 함수 사용!
   - 주어진 다리를 모두 순회하면 탐색을 종료합니다.

6. answer 값을 반환합니다.

   - 연결할 수 없는 섬은 주어지지 않았으므로, 모든 섬이 연결되었는지 확인할 필요는 없습니다.

   

# 제출 코드

### 첫 시도

```jsx
function solution(n, costs) {
    var answer = 0;
    
    // step 0. 각 섬이 연결되었는지 여부를 알려줄 unf 배열 선언하고 초기화
    let unf = Array.from({length : n + 1}, (value, idx) => idx);
    
    // step 1. 다리의 건설 비용이 가장 작은 순으로 정렬
    costs.sort((a, b) => a[2] - b[2]);
    
    // step 2. find 함수와 union 함수 선언
    function Find(i) {
        if (unf[i] === i) {
            return unf[i];
        } else {
            unf[i] = Find(unf[i]);
            return unf[i];
        }
    }
    
    function Union(a, b) {
        if (Find(a) !== Find(b)) {
            unf[b] = Find(a);
        }
    }
    
    // step 3. 다리 탐색
    for (let [a, b, cost] of costs) {
        if (Find(a) !== Find(b)) {
            answer += cost;
            Union(a, b);
        }
    }
    
    return answer;
}
```

