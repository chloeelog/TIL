# [TIL] 2021-09-05

> 알고리즘  - JavaScript



# 01. 수열 축소

### guideline

- 인덱스 순회 하며, [i]와 [i+1]을 비교한 값을 [i]에 바로 넣는다.
- `slice(0, n-m)`
- 메모리 낭비 없이 배열 하나를 사용해서 바로 할 수 있는 방법!


# 02. 가장 높은 증가수열

> 탐색하면서 인접한 두 수의 차이가 양수일 경우 누적한다. 음수일 경우 누적된 합이 증가수열의 높이가 된다.

### guideline

1. `i = 1`로 시작하여, `nums[i - 1]`과 `nums[i]`를 비교한다.
    - 만약 두 수의 차이가 양수일 경우에만 이 차이를 누적하여 계산한다.
2. 두 수의 차이가 음수가 될 경우 그때까지의 누적값을 answer와 비교하여 더 큰 값을 answer로 반환한다.
3. 누적한 값을 초기화하고 다시 탐색을 시작한다.

### 내 코드 ⚠️ 디버깅 필요

```jsx
function solution(nums) {
  let answer = 0;
  
  let sum = 0;

  for (let i = 1; i < nums.length; i++) {
    const diff = nums[i] - nums[i - 1];
    
    if (diff > 0) {
      sum += diff
    } else {
      answer = Math.max(answer, sum);
      sum = 0;
    };

  };

  return answer;
}

console.log(solution([5, 2, 4, 7, 7, 3, 9, 10, 11]))
```

- 맨 마지막 수가 포함되는 증가수열의 높이가 최대일 경우를 누락한다!
    - 그러므로 맨 마지막에 한 번 더 갱신해주어야 한다.



# 03. 가장 긴 수열

### 내 코드  ⚠️디버깅 필요!

```jsx
function solution(nums) {
  let answer = 0;

  let asc = 1;
  let des = 1;

  for (let i = 1; i < nums.length; i++) {
    if (nums[i] > nums[i - 1]) {
      asc++;
      answer = Math.max(answer, des);
      des = 1;
    } else if (nums[i] < nums[i - 1]) {
      des++;
      answer = Math.max(answer, asc)
      asc = 1;
    } else {
      answer = Math.max(answer, asc, des)
      asc = 1;
      des = 1;
    };
	// 한번 더 갱신해주자!
  }
  
  return answer;
}
```



# 04. 바이토닉 수열

> 쭉 증가했다 봉우리가 만들어지고 쭉 감소하거나, 반대로 쭉 감소했다가 골짜기가 만들어지고 쭉 증가하는 수열.

### guideline

1. `while ( i+1 < n && nums[i] < nums[i+1] )` 일 경우 `i++` 
2. `if (i === (n-1) || i === 0)` → 쭉 증가하거나 쭉 감소하는 수열인 경우는 return NO
3. 반대로 `while ( i+1 < n && nums[i] > nums[i+1] )` 일 경우 `i++`
4. `if (i !== (n-1) )` → 끝까지 감소하여 오지 못한 경우이므로 return NO

- 주의! while 문 내부에 `(i인덱스 검증 && 차이 비교)` 의 순서를 바꿔서 쓰지 말 것!
    - `(차이 비교 && i인덱스 검증)` 으로 구현할 경우, 앞쪽 항에서 index error가 발생할 수 있다.
    - 그러므로 인덱스를 먼저 검증하고 차이를 비교하도록 하자!

```jsx
function solution(nums) {
  let i = 0;

  while (i + 1 < nums.length && nums[i] < nums[i + 1]) {
    i++;
  }
  if (i === nums.length - 1 || i === 0) {
    return "NO";
  }

  while (i + 1 < nums.length && nums[i] > nums[i + 1]) {
    i++;
  }
  if (i !== nums.length - 1) {
    return "NO";
  }

  return "YES";
}
console.log(solution([1, 2, 3, 4, 5, 3]));
```

# 05. 거리 두기

> for문으로 왼쪽으로부터의 거리만 먼저 구하고, 반대로 다시 for문으로 오른쪽으로부터의 거리만 먼저 구한다.

1. 인덱스를 증가시켜가며 오른쪽으로 순회하며, (=내 왼쪽 사람과의 거리 구하기)
    - 거리값dis을 변수로 지정하고, 초기값을 아주 큰 값으로 설정한다.
    - 0을 만날 경우 거리값dis을 1 증가시키고 그 값을 거리 배열에 집어넣는다.
    - 1을 만날 경우 dis를 0으로 초기화하고 그 값을 거리 배열에 집어넣는다.
2. 인덱스를 감소시켜가며 왼쪽으로 순회하며, (내 오른쪽 사람과의 거리 구하기)
    - 다시 거리값dis을 아주 큰 값으로 설정한다.
    - 1을 만날 경우 dis를 0으로 초기화한다. 그 값을 거리 배열에 집어넣을 필요는 없다.
    - 0을 만날 경우 거리값dis을 1 증가시키고, 그 값을 배열 내의 값과 비교하여 더 작은 값을 집어넣는다.
        - 왼쪽 사람과의 거리든 오른쪽 사람과의 거리든, '가장 가까운 사람과의 거리'를 구해야 하므로!
3. 거리 배열의 값들 중 가장 큰 값을 구한다. 

### 내 코드

```jsx
function solution(nums) {
  let arr = Array.from({length: nums.length}, () => 0)

  let dist = 1000;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      dist++;
      arr[i] = dist;
    } else if (nums[i] === 1) {
      dist = 0;
      arr[i] = dist;
    };
  };

  dist = 1000;
  for (let i = nums.length - 1; i > -1; i--) {
    if (nums[i] === 0) {
      dist++;
      arr[i] = Math.min(arr[i], dist);
    } else if (nums[i] === 1) {
      dist = 0;
    };
  };

  const answer = Math.max(...arr);
  return answer;

}
console.log(solution([1, 0, 0, 0, 1, 0, 0, 1, 0, 1]));
```


# 06. 2차원 배열 1의 개수

> map, reduce를 활용하여 풀어보자!

```jsx
function solution(nums) {
  let answer = nums.map((row, idx) => 
    ({
      idx, 
      cnt: row.reduce((accumulator, current) => {
        return accumulator + current
      }, 0)}))
  .sort((a, b) => a.cnt - b.cnt)
  .map(object => object.idx);

  return answer;
    
}
console.log(solution([[1, 0, 0, 1], [0, 0, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]));
```

# 07. 행과열의 최솟값

### 내가 해서 틀린 코드

```jsx
function solution(nums) {
  let answer = [];

  for (let i = 0; i < nums.length; i++) {
    const minValue = Math.min(...nums[i]);
    const col = nums[i].indexOf(minValue);

    for (let j = 0; j < nums.length; j++) {
      if (nums[j][col] < minValue) {
        break;

			// 이 부분에 break 없이 끝나는 경우로 걸어주면 된다!
			// 그렇지 않으면 행의 갯수만큼 반복해서 push 하게 되어버린다! 
      } else {
        answer.push(minValue)
      };
    };

    answer.sort((a, b) => a - b)
  }

  return answer;
    
}

console.log(solution([[4, 6, 22, 1], [9, 3, 10, 12], [30, 7, 20, 2], [15, 8, 5, 13]]))
```


# 08. 봉우리

> 델타 탐색을 활용하자!

### 내가 했는데 또 에러난 코드 ⚠️

```jsx
function solution(nums) {
  let answer = 0;
  const n = nums.length;

  let dr = [-1, 0, 1, 0];
  let dc = [0, 1, 0, -1];

  for (let i = 1; i < n - 1; i++) {
    for (let j = 1; j < n - 1; j++) {
      let flag = true;

      for (let d = 0; d < 4; d++) {
        if (nums[i][j] <= nums[i + dr[d]][j + dc[d]]) {
          flag = false;
        };
      };

      if (flag) {
        answer++;
      };
    };
  };

  return answer;
}

console.log(solution([[5, 3, 7, 2, 3], [3, 7, 1, 6, 1], [7, 2, 5, 3, 4], [4, 3, 6, 4, 1], [8, 7, 3, 5, 2]]))
```

- 격자판의 테두리는 초기화되어있다고 가정하고 있으므로! 입력값의 테두리를 걸러내면 안된다!



# 추가문제 : 졸업선물 (사전과제 day3 02)

```jsx
function solution(product, m) {
  let answer = 0;

  let n = product.length;
  product.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]))

  for (let i = 0; i < n; i++) {
    let money = m - (product[i][0]/2 + product[i][1])
    let cnt = 1;
    for (let j = 1; j < n; j++) {
      if (j !== i && (product[j][0] + product[j][1]) > money) break;
      if (j !== i && (product[j][0] + product[j][1]) <= money) {
        money -= (product[j][0] + product[j][1]);
        cnt++;
      }
    }
    answer = Math.max(answer, cnt);
  }

  return answer;
}
```

- 완전탐색 문제.

