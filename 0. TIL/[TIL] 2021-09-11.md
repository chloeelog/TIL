# [TIL] 2021-09-11

> 알고리즘  - JavaScript

## 프로그래밍 1 : clear
```jsx
function solution(id_list, report, k) {
  var answer = [];

  // 중복 신고 걸러내기
  report = new Set(report);

  let uH = new Map();
  let iH = new Map();

  for (let rep of report) {
    const [user, ID] = rep.split(" ");

    // 각 유저에 대해, 신고당한 누적 횟수와 신고자 맵
    if (uH.get(ID)) {
      const freq = uH.get(ID)[0] + 1;
      const ids = uH.get(ID)[1].concat([user]);
      uH.set(ID, [freq, ids]);
    } else {
      uH.set(ID, [1, [user]]);
    }
  }

  for (let [key, value] of uH) {
    if (value[0] >= k) {
      for (let user of value[1]) {
        iH.set(user, iH.get(user) + 1 || 1);
      }
    }
  }

  for (let id of id_list) {
    answer.push(iH.get(id) || 0);
  }

  return answer;
}
```

## 프로그래밍 2 
> testcase 1 시간초과

```jsx
function solution(n, k) {
  var answer = 0;

  // k진수로 변환
  let num = "";
  while (n >= 1) {
    num = (n % k) + num;
    n = parseInt(n / k);
  }

  // 소수의 후보가 될 수 있는 수들
  const candis = num.split("0");

  // 소수 판별 함수
  function Prime(num) {
    num = Number(num);
    if (num === 1 || num === 0) {
      return false;
    } else {
      for (let i = 2; i < (num / 2); i++) {
        if (num % i === 0) {
          return false;
        }
      }
      return true;
    }
  }

  // 소수 판별하여 값 반환하기
  for (let candi of candis) {
    if (Prime(candi)) {
      answer++;
    }
  }

  return answer;
}
```

## 프로그래밍 3 : clear
```jsx
function solution(fees, records) {
  var answer = [];

  // 각 차량별 입출차 내역 기록하기
  let cH = new Map();
  let IO_record = [];
  
  for (let record of records) {
    const [time, car, inout] = record.split(" ");
    if (cH.get(car)) {
      const in_time = cH.get(car)[0];
      IO_record.push([car, [in_time, time, 0]]);
      cH.delete(car)
    } else {
      cH.set(car, [time, "23:59", 0])
    }
  }

  for (let [key, value] of cH) {
    IO_record.push([key, value])
  }
  
  let tH = new Map();
  for (let [car, value] of IO_record) {
    // 입출차 시간 변환하여 구하기
    const [in_hour, in_min] = value[0].split(":");
    const in_time = Number(in_hour) * 60 + Number(in_min);
    const [out_hour, out_min] = value[1].split(":");
    const out_time = Number(out_hour) * 60 + Number(out_min);
    
    // 총 주차 시간 구하기
    const min = out_time - in_time;
    // console.log(`${car}번 차량 ${in_hour}시${in_min}분 입차, ${out_hour}시${out_min}분 출차 / ${out_time} 빼기 ${in_time} 해서 ${min}분 사용`)

    tH.set(car, tH.get(car) + min || min);
  }
  
  // 각 차량 별 금액 배열로 불러오기
  let temp = [];
  for (let [key, value] of tH) {
    // 요금 정산하기
    const cost = (value > fees[0]) ? (fees[1] + (Math.ceil((value - fees[0])/fees[2]) * fees[3])) : (fees[1])
    // console.log(`${value} 주차하기 때문에 ${cost}원을 냅니다`)
    temp.push([key, cost])
  }

  answer = temp.sort((a, b) => a[0] - b[0]).map((val, idx) => {
    return val[1];
  })

  return answer;
}
```

## 프로그래밍 4
> 심한 에러... 디버깅 절실

```jsx
function solution(n, info) {
  var answer = [];

  // 해당 점수를 얻기 위해 라이언이 쏴야 하는 화살의 갯수
  const need = info.map((val, idx) => val + 1);
  // console.log(need);
    
  let max = Number.MIN_SAFE_INTEGER;
  let cases = [];

  // 라이언이 열 발을 모두 쏠 때의 모든 경우 완전탐색
  function comb(arrow, idx, arr, score, apeach) {
      if (arrow === 0) {
          const diff = score - apeach;
          if (diff > max) {
              max = diff;
              cases = [arr];
          } else if (diff === max) {
              cases.push(arr);
          } else {
              return false;
          }
      } else if (idx < 11) {
          const cur = need[idx];
          if (arrow >= cur) {
              arr[idx] = cur;
              comb(arrow - cur, idx + 1, arr, score + (10 - idx), apeach);
              arr[idx] = 0;
              comb(arrow, idx + 1, arr, score, (info[idx] === 0) ? apeach : apeach + (10 - idx));
          } else {
              comb(arrow, idx + 1, arr, score, (info[idx] === 0) ? apeach : apeach + (10 - idx));
          }
      }
  }

  let arr = Array.from({length: 11}, () => 0);
  comb(n, 0, arr, 0, 0);
    
  answer = -1;
  if (cases.length > 0) {
      answer = cases[0];
  }
  return answer;
}
```

## 프로그래밍 5 
> 마찬가지로 심한 에러... 디버깅 해야한다...

```jsx
function solution(info, edges) {
    var answer = 0;
    
    const n = info.length;
    const table = Array.from({length: n}, () => Array(n).fill(false));
    
    for (let [parent, child] of edges) {
        table[parent][child] = true;
        table[child][parent] = true;
    }
    
    function search(node, sheeps, wolves, visited, route) {
        // 양이 잡아먹히게 되는 순간 탐색 종료!
        if (sheeps === wolves) {
            // console.log(`${route}만큼 다녀왔는데 양이 잡아먹혔어요!`)
            return;
        } else {
            // 모아놓은 양의 최댓값을 갱신하고,
            max = Math.max(max, sheeps);
            // console.log(`현재 ${node}에 있어요. ${max}만큼 모았고, ${route}만큼 다녀왔어요.`)
            // console.log(`이 때 방문배열을 확인해볼까요? ${visited}`)
            
            // 모두 탐색했는지 확인해볼까요? 더 이상 탐색할 곳이 없다면 탐색 종료!
            let flag = false;
            for (let val of visited) {
                if (val === false) {
                    flag = true;
                }
            }
            
            if (flag === false) {
                // console.log(`다 탐색했어요~!`)
                return;
            } else if (flag === true) {
                // 다음 탐색할 곳을 찾아본 뒤,
                let next = [];
                for (let i = 0; i < n; i++) {
                    if (table[node][i] === true) {
                        next.push(i);
                    }
                }

                // console.log(`${node}에서 ${next}로 넘어가볼 예정이에요.`)
                // 탐색을 보내봅니다!
                for (let n of next) {
                    // 방문한 적 있다면 더하거나 빼지 않고 이동만 해줄게요!
                    if (visited[n] === true) {
                        search(n, sheeps, wolves, visited, route + node);

                    // 방문한 적 없다면 분기해줍니다.
                    } else {
                        visited[n] = true;
                        if (info[n] === 0) {
                            search(n, sheeps++, wolves, visited, route + node);
                        } else if (info[n] === 1) {
                            search(n, sheeps, wolves++, visited, route + node);
                        }
                    }
                }   
            }
        }
    }
    
    const visited = Array.from({length: n}, () => false);
    let max = Number.MIN_SAFE_INTEGER;
    search(0, 1, 0, visited, "*");
    
    answer = max;
    
    return answer;
}
```
