# [TIL] 2021-09-09

> 알고리즘  - JavaScript

# 00. ASCII 코드 연습

### 문제

- `aBAcbD`를 정렬하라 :
    - 대문자가 먼저, 소문자가 나중에
    - 대문자들끼리, 소문자들끼리는 아스키 코드 순서로

### 내 코드 : `sort()` function 없이 걸면 바로 알파벳으로 가능!

```jsx
function solution(s) {
  let answer = s
    .split("")
    .sort()
    .join("");
  return answer;
}
```

# 01. 동전교환

## 개념 정리 : Greedy 탐욕 알고리즘

- 매 순간 최선의 선택지를 고르는 방식.
- 부분 최적의 누적합이 결과적으로 전체의 최적이 될 것이라고 전제한다.
- 증명이 어렵기에, 알고리즘을 증명하기보다는 반례를 찾아본다.

### guideline

1. 가장 큰 단위로 나눈 몫을 반환하고,
2. 나머지 금액을 남은 것들 중 가장 큰 단위로 나눈 몫을 반환한다.
- 특수한 조건이 주어진 경우이기에 가능한 문제:
    - 항상 1원짜리 동전이 주어지고,
    - 한 단위의 동전이 그 전 단위 동전의 배수이기에 성립한다!


# 02. 침몰하는 타이타닉

### guideline

1. 승객들을 몸무게 순으로 정렬하고,
2. `lt`, `rt`의 투 포인트를 설정한다.
3. `lt`, `rt`를 더한 값을 구명보트 수용 가능 무게와 비교하여,
    1. 합이 더 클 경우 `rt`를 감소시키고 보트 하나를 카운트하고
        - 몸무게가 가장 무거운 사람이 혼자 보트를 타는 경우
    2. 합이 더 크지 않을 경우 `lt`를 증가시키고 `rt`를 감소시키며 보트 하나를 카운트한다.
        - 가장 무거운 사람과 가장 가벼운 사람이 함께 보트를 타는 경우
- `lt`, `rt`가 일치하는 순간 (한 사람만 남은 순간) 은 예외 경우가 아니므로 따로 처리해주지 않아도 좋다!

# 03. 회의실 배정

> greedy의 기본 문제!

### guideline

- 끝나는 시간을 기준으로 정렬하여 처리하는 것이 합리적이다.
1. 제일 먼저 끝나는 회의를 선택하고,
2. 겹치지 않는 회의들 중 가장 먼저 끝나는 회의를 선택하는 방식으로 진행한다.

### 내 코드 : after → 정렬 반례 주의하여 점검해보기

```jsx
function solution(meeting) {
  let answer = 0;

  meeting.sort((a, b) => (a[1] - b[1]))

  let cur = 0;
  let pre = meeting[cur][1]
  answer++;

  while (cur < meeting.length) {
    if (meeting[cur][0] < pre) {
      cur++;
    } else {
      pre = meeting[cur][1];
      answer++;
    }
  }
  return answer;
}

console.log(solution([[1, 4], [2, 3], [3, 5], [4, 6], [5, 7]]));
```

- 조건에 유의하자: 전 회의가 끝나는 시간과 다음 회의가 시작하는 시간이 겹칠 수 있다!
    - 그러므로 `pre ≥ meeting[cur][0]` 인 경우에 answer가 성립할 수 있다!

# 04. 마지막 남은 수

> max Heap 문제. 다른 언어들은 힙 자료구조의 라이브러리가 있지만 JS는 없기 때문에 직접 구현해야 한다.

- for문 내에서 sort로 정렬을 돌리면 효율성을 통과할 수 없다:
    - 이 때의 시간복잡도는 `O(nlog(n))` 이 된다.
- 맥스힙을 사용하면 이진 트리 두 번으로 풀 수 있다:
    - `O(2log(n))`으로 해결하자!

## 개념 정리 : max Heap

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cedeffec-e928-4318-bbb6-ef9f31d41948/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cedeffec-e928-4318-bbb6-ef9f31d41948/Untitled.png)

### 이진 트리의 인덱스 탐색법

- 어떤 노드의 자식 노드 인덱스를 구하기 :
    - `부모 노드 인덱스 * 2`
    - `부모 노드 인덱스 * 2 + 1`
- 어떤 노드의 부모 노드 인덱스를 구하기 :
    - `자식 인덱스 / 2`

### 맥스힙 구현법

- 맥스힙의 조건 : 부모 노드가 반드시 자식 노드보다 작지 않다. 반드시 크거나 같다.
1. 충분한 크기의 배열을 생성한다.
2. 0번 인덱스에는 아주 큰 값을 배정한다.
3. 1번 인덱스(노드) 부터 주어진 자료를 차례대로 배정하며,
4. 배정된 노드에 부모 노드가 존재한다면 부모 노드의 값과 크기를 비교하고,
    1. 만약 부모 노드보다 큰 값이라면 부모 노드와 자리를 바꿔준다.
        - 새로 배정된 자리에서 다시 한 번 새로운 부모 노드의 값과 크기를 비교한다.
    2. 부모 노드보다 작거나 같다면 break.

### 맥스힙을 구현해보자!

- `[5, 4, 3, 6, 7, 2, 9]`
    - 나의 코드 : 실패!

```jsx
        function solution(arr) {
          // let maxHeap = Array.from({length: arr.length + 1}, (value, idx) => 0);
          // maxHeap[0] = 1000;
          let maxHeap = [1000];

          for (let i = 1; i < arr.length; i++) {
            maxHeap.push(arr[i]);
            let cur_idx = maxHeap.length;

            while (maxHeap[(parseInt(cur_idx / 2))] < maxHeap[cur_idx]) {
              let temp = maxHeap[cur_idx];
              maxHeap[cur_idx] = maxHeap[(parseInt(cur_idx / 2))];
              maxHeap[(parseInt(cur_idx / 2))] = temp;
              cur_idx = (parseInt(cur_idx / 2))
            }
            while (maxHeap[])

          }

          return maxHeap;
        }
```

# 05. 수열의 높이 조정

###  코드

```jsx
function solution(nums, m){
    let answer=0;
    nums.sort((a, b)=>a-b);
    for(let i=0; i<m; i++){
        nums[0]++;
        nums[nums.length-1]--;
        nums.sort((a, b)=>a-b);
        if(nums[0]===nums[nums.length-1]) break;
    }
    answer=nums[nums.length-1]-nums[0];
    return answer;
}
console.log(solution([2, 1, 3, 7, 5], 2));

<개선된 코드>
function solution(nums, m){
    let answer=0;
    let ch=Array.from({length:1001}, ()=>0);
    let maxH=Number.MIN_SAFE_INTEGER;
    let minH=Number.MAX_SAFE_INTEGER;
    for(let x of nums){
        ch[x]+=1;
        if(x>maxH) maxH=x;
        if(x<minH) minH=x;
    }
    for(let i=1; i<=m; i++){
        if(maxH===minH) return 0;
        if(ch[maxH]===1){
            ch[maxH]--;
            maxH--;
            ch[maxH]++;
        }
        else{
            ch[maxH]--;
            ch[maxH-1]++;
        }
        if(ch[minH]===1){
            ch[minH]--;
            minH++;
            ch[minH]++;
        }
        else{
            ch[minH]--;
            ch[minH+1]++;
        }
    }
    answer=maxH-minH;
    return answer;
}
console.log(solution([2, 1, 3, 7, 5], 2));
```

# 06. 최대 수입 스케줄

> `우선순위 큐`를 써서 greedy 기법으로 접근한다!

###  guideline

1. 주어진 강연을 날짜를 기준으로 내림차순한다.
2. 마지막 날짜부터 거슬러 오면서 해당 날짜에 가능한 가장 비싼 강연을 고른다: 
    1. 해당 날짜까지인 강연의 금액을 maxHeap에 insert 한 뒤,
    2. 현재 maxHeap의 최상위 노드 = 최댓값을 get 한다. 
3. 첫 날까지 반복하며 최댓값을 누적하여 반환한다.

### 내 코드 : after → while문 idx 조건 점검하기

```jsx
// class maxHeap 구현

function solution(nums) {
  let answer = 0;

  nums = nums.sort((a, b) => b[1] - a[1]);
  console.log(nums)

  let maxH = new maxHeap();
  let idx = 0;

  for (let day = nums[0][1]; day > 0; day--) {
    console.log(`${day}일에 끝나는 강연의 금액은:`)
    while (idx < nums.length && nums[idx][1] === day) {
      console.log(`${nums[idx][0]}원 입니다!`)
      maxH.insert(nums[idx][0]);
      idx++;
    }
    console.log(`이 때 남아있는 강연들 중 최대 금액을 더하면`)
    answer += maxH.get();
    console.log(`${answer}원 입니다!`)
  }

  return answer;
}

console.log(
  solution([
    [50, 2],
    [20, 1],
    [40, 2],
    [60, 3],
    [30, 3],
    [30, 1]
  ])
);
```